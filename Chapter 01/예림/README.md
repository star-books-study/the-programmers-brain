# Chapter 1. 코딩 중 겪는 혼란에 대한 이해

- 프로그래밍을 하다 보면 늘 혼란이 일어난다.
- 물론 잠시의 혼란스러움은 문제가 되지 않겠지만, 그것을 필요 이상으로 오래 가져가서는 안된다.
- 혼란은 세 가지 다른 방식으로 일어난다. 이들 여러 가지 종류의 혼란은 서로 다른 유형의 **인지 과정**과 관련 있다.

## 코드가 초래하는 세 가지 종류의 혼란
- 이 혼란에 대해 세 가지 다른 종류의 예제 코드로 설명해보겠다. 다음 코드는 모두 주어진 숫자 N 혹은 n을 이진수로 바꾸는 일을 한다.
- 첫 번째 코드는 APL이고, 두 번쨰는 자바, 세 번째는 베이직이다.
- 코드를 읽을 때 어떤 종류의 지식을 사용하고, 그 지식은 어떻게 다른가?

- APL에서의 이진수 표현
  ```apl
  
  2 2 2 2 2 T n
  ```

- 자바에서의 이진수 표현
  ```java
  public class BinaryCalculator {
    public static void mian(Integer n) {
      System.out.println(Integer.toBinaryString(n));
    }
  }
  ```

- 베이직에서의 이진수 표현
  ```basic
  LET N2 = ABS(INT(N))
  LET B$ = ""
  FOR N1 = N2 TO 0 STEP 0
    LET N2 = INT(N1 / 2)
    LET B$ = STR$(N1 - N2 * 2) + B$
    LET N1 = N2
  NEXT N1
  PRINT B$
  ```

### 1.1.1 혼란의 첫 번째 유형 : 지식의 부족
- 첫 번째 예제 코드를 보고 혼란스러운 이유는 `T`가 의미하는 바를 모르기 때문이다.
- 대부분은 APL을 보를 테니 연산자 T의 의미도 모를 것이다.
- 즉 코드가 혼란스러운 이유는 T가 의미하는 바를 모르기 때문이다. ➡️ **T에 대한 `지식`이 없기 때문이다.**

### 1.1.2 혼란의 두 번째 유형 : 정보의 부족
- 두 번째 예제 코드를 보고 프로그래밍 언어를 어느 정도 알고 있는 독자라면 이진수 표현으로 변환하는 부분을 찾을 수 있다.
- 하지만 toBinaryString() 메서드가 내부적으로 어떻게 작동하는지 모른다면 이 코드도 혼란스러울 수 있다.
- 여기서 혼란의 원인은 **이 메서드에 대한 `정보`가 부족하다는 점이다.**

### 1.1.3 혼란의 세 번째 유형 : 처리 능력의 부족
- 세 번째 코드에서는 변수 이름이나 연산자를 통해 코드가 무슨 일을 하는지 유추할 수 있다.
- 하지만 코드를 따라가다 보면 머릿 속에서 모든 과정을 처리하기가 어렵다.
- 이러한 혼란은 **`처리능력`이 부족하기 때문이다.**


혼란을 초래하는 원인을 세 개의 예제 프로그램을 통해 살펴봤다.
1. 프로그래밍 언어나 알고리즘 혹은 업무 영역에 대한 지식이 없는 경우
2. 코드를 이해하기 위해 필요한 정보를 충분히 가지고 있지 못하는 경우
3. 코드가 너무 복잡해서 혼란이 생기는 경우 (두뇌의 처리 용량이 부족하기 때문)


## 1.2 코딩에 영향을 주는 인지 과정

우리가 여러 종류의 혼란을 겪을 때 다음과 같은 서로 다른 종류의 인지 과정이 연관된다.
- **지식의 부족** = `장기 기억 공간(long-term memory, LTM)`의 문제
- **정보의 부족** = `단기 기억 공간(short-term memory, STM)`의 문제
- **처리 능력의 부족** = `작업 기억 공간(working memory)`의 문제


### 1.2.1 LTM과 프로그래밍
- LTM은 프로그래밍과 관련해서 여러 가지 다른 종류의 정보를 저장한다.
  - 예를 들어 어떤 기술을 성공적으로 적용한 순간, 자바 언어에서 키워드의 의미나 maxint의 값이 2147483647이라는 사실, 혹은 영어 단어의 의미 등이다.
- LTM은 오랜 시간 동안 저장한다는 점에서 **컴퓨터의 하드 드라이브와 비슷**하다.

#### APL 프로그램 : LTM
- APL 예제 코드를 통해 **언어의 문법**에 대한 지식도 중요하다는 사실을 알 수 있다.
- `T`가 어떤 수의 값을 다른 진법의 수로 변환해주는 이항 부호화(dyadic encode) 함수라는 것을 알면 코드 분석은 간단해진다.

### 1.2.2 STM과 프로그래밍
- STM은 들어오는 정보를 잠시 보관하기 위해 사용된다.
- STM은 크기에 제한이 있는데, 이 크기에 대한 추정치는 학자마다 다르지만 STM이 기억할 수 있는 항목의 최대치가 12개를 넘지 않는다는 점에는 대부분의 학자가 동의한다.

#### 자바 프로그램 : STM
- STM은 `n`이 정수형 숫자라는 사실을 일정 기관 보관한다. 두 번째 라인에 이르렀을 때는 `toBinaryString()`이 반환하는 결과가 무엇인지 알게 된다.
- 이 함수가 어떤 일을 하는지 파악했더라도, 하루 혹은 한 시간이 지나기 전 잊어버릴 수 있다. 이 함수가 하는 일을 이해하고 나면 STM은 그 내용을 기억에서 지워버린다. 
- 이 코드를 이해하는 데 LTM 역시 사용된다. 사실 LTM은 우리가 행하는 모든 인지 과정에 관여한다.
- 이 코드가 어떤 일을 하는지 설명해보라고 하면 `public class`와 `public static void main`은 굳이 설명하지 않을 것이다.
- 우리 두뇌는 함수명을 미리 가정하는데 여기서 두 가지 인지 과정이 동시에 일어난다.
  - `mian`을 읽을 때 이것은 STM에 저장되지만, 이 함수명을 사용하는 대신 `main`이라고 하는, LTM에 저장되어 있는 이름을 사용한다.
  ➡️ **두 가지 인지 과정이 서로 독립적으로 일어나는 것이 아니다.**
- STM은 값을 일시적으로 저장하는 **캐시나 메인 메모리**라고 할 수 있다.


### 1.2.3 작업 기억 공간과 프로그래밍
- 실제 사고 작용은 LTM이나 STM이 아닌 작업 기억 공간에서 일어난다.
- 생각, 아이디어, 해결책 같은 것들은 여기에서 만들어진다.
- LTM은 하드 드라이브, STM은 메인 메모리로 생각한다면, 작업 기억 공간은 **두뇌의 프로세서**라고 볼 수 있다.
#### 베이직 : 작업 기억 공간
- LET이나 EXIT 같은 키워드의 의미를 기억해내기 위해 LTM 사용
- B$가 빈 문자열로 시작된다는 것과 같은 정보는 STM에 저장
- 하지만 베이직 코드를 읽을 때에는 우리의 머리가 코드를 실행해보면서 무슨 일이 일어날지 시도 ➡️ 이 과정을 **트레이싱**이라고 부른다.
  - 트레이싱 : 머릿 속에서 코드를 컴파일하고 실행하는 과정
- 트레이스를 하거나 인지적으로 복잡한 작업을 할 때 사용되는 두뇌를 **작업 기억 공간**이라고 한다.

> 💡 매우 복잡한 프로그램을 트레이스할 때는 별도로 적어놓고 싶은 마음이 들 수도 있는데, 이는 작업 기억 공간이 꽉 차서 더 많은 정보를 처리할 수 없을 때 나타날 수 있다.


## 1.3 인지 과정들의 상호작용

### 1.3.1 인지 과정들이 어떻게 상호작용하는지에 대한 간단한 설명
- 우리가 사고할 때는 이 세 가지 인지 과정 모두 어느 정도 활성화된다.
![image](https://github.com/user-attachments/assets/cecc08a8-ca92-4d28-8e7b-c93f80912f9c)

### 1.3.2 프로그래밍 업무와 관련한 인지 과정
- 고객으로부터 오프바이원 오류(off-by-one error)에 기인한 버그 리포트를 받는 상황
  - STM - 새로운 버그 리포트의 내용, 몇 개월 전 작성한 코드를 분석할 때 읽는 내용
  - LTM - 몇 개월 전 구현한 내용, 오프바이원 오류의 해결법
  - 작업 기억 공간 - STM에 저장된 내용과 LTM에 저장된 내용이 들어오고, 비로소 당면 문제에 대해 생각할 수 있게 된다.
