# Chapter 4. 복잡한 코드 읽는 방법
- 이 장의 목표
  - 복잡한 코드를 좀 더 쉽게 다루도록 작업 기억 공간을 돕는 3가지 기법 소개

## 4.1. 복잡한 코드를 이해하는 것이 왜 어려울까?
- 작업 기억 공간 : 두뇌가 생각하고, 새로운 아이디어를 형성하고, 문제를 해결하는 능력에 해당
  - 두뇌의 프로세서와 같다

### 4.1.1. 작업 기억 공간과 STM 의 차이
- STM 의 역할이 **정보를 기억하는 것**인 반면, 작업 기억 공간의 역할은 **정보를 처리하는 것**이다
- 작업 기억 공간도 **특정한 문제에 적용된 STM** 이기 때문에 STM 과 같은 제한이 있다
  - 2~6개로 작업 기억 공간의 맥락에서 이 용량을 `인지 부하` 라고 부른다.

### 4.1.2. 프로그래밍과 관련한 인지 부하의 종류
- 내재적 부하 : **문제 자체**가 얼마나 복잡한지
- 외재적 부하 : **외부적 요인**에 의해 문제에 추가된 것
- 본유적 부하 : 생각을 **LTM에 저장하는 과정에서** 일어나는 인지 부하

#### 코드를 읽을 때 내재적 인지 부하
- 내재적 인지 부하는 **문제 그 자체가 갖는 특성** 때문에 발생하는 인지 부하다

#### 코드를 읽을 때 외재적 인지 부하
- 외재적 인지 부하는 어떤 문제가 두뇌에 일으키는 **자연적이고 내재적인 부하에 '더해서' 문제에 추가**되는 인지부하다
- 외재적 부하는 프로그래밍의 우발적 복합성과 유사하다
  - 우발적 복합성 <-> 본질적 복합성 (문제 자체의 복합성)
  - 우발적 복합성 : 문제 그 자체보다 문제를 풀려는 과정이 과도하게 복잡해진 것
- **외재적 인지 부하가 동일한지 여부는 이미 갖고 있는 지식에 달려 있다**

## 4.2. 인지 부하를 줄이기 위한 기법
### 4.2.1. 리팩터링
- 대개 리팩터링은 코드의 유지보수를 쉽게 하기 위한 목적으로 이루어진다 
- 하지만 코드가 전체적으로 유지보수하기 좋게 수정되었다고 해서 가독성까지 반드시 좋아지는 것은 아니다
  - **탈국지화된 코드는 여러 군데서 메서드 내부 구현을 찾아봐야 해서 작업 기억 공간에는 어려움을 줄 수 있다**
- `인지적 리팩터링` : 유지보수하기 좋은 코드를 작성하기보다, 장기적으로 가독성이 높은 코드를 작성하는 것
  - 리팩토링과 마찬가지로 코드가 외부로 제공하는 기능을 변경하지는 않는다
  - 다만 목표가 코드를 유지보수하기 좋게 만드는 게 아니라 **현 시점에서 개발자가 읽기 쉬운 코드로 변경하는 것**
  - 때로는 역 리팩토링을 수반할 수도 있다. 즉, 오히려 코드의 유지보수성을 낮추는 결과를 가져올 수도 있다
    - ex) 인라인 메소드 구현 : 외재적 인지 부하를 낮추고 코드를 이해하는 데 도움이 된다
    - ex) 코드 내 메소드 순서 변경 : 어떤 메소드가 최초로 호출되는 위치로부터 가까이 정의되어 있다면 코드의 가독성이 좋아진다
- 사람마다 지식에 따라 코드 이해도와 리팩토링 하는 내용도 다르므로 인지적 리팩토링은 개발자 자신만을 위한 리팩토링이다

### 4.2.2. 생소한 언어 구성 요소를 다른 것으로 대치하기
- 익숙하지 않은 언어 구성 요소는 작업 기억 공간에 외재적 인지 부하를 늘리므로, 복잡한 코드를 읽을 때 이들로 인한 부하가 늘어나지 않도록 하는 게 좋다
  - ex) 람다, 3항 연산자

### 4.2.3. 플래시카드에 코드 동의어 추가
- 프로그래밍 언어의 고급 개념에 대해서는, 프롬프트 대신 플래시카드 앞면까지 양면에 모두 코드를 적으면 더 나은 효과를 얻을 수 있다
- 앞면 : 삼항 연산자, 람다 같은 고급 개념 사용한 코드 / 뒷면 : 그에 해당하는 전통적인 방식의 코드

> 1. 인지 부하를 줄이기 위해 리팩토링 시 인라인 메소드 구현으로 대체하는 것도 고려해보자