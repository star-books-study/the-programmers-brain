# Chapter 4. 복잡한 코드 읽는 방법
- 이 장의 목표
  - 복잡한 코드를 좀 더 쉽게 다루도록 작업 기억 공간을 돕는 3가지 기법 소개

## 4.1. 복잡한 코드를 이해하는 것이 왜 어려울까?
- 작업 기억 공간 : 두뇌가 생각하고, 새로운 아이디어를 형성하고, 문제를 해결하는 능력에 해당
  - 두뇌의 프로세서와 같다

### 4.1.1. 작업 기억 공간과 STM 의 차이
- STM 의 역할이 **정보를 기억하는 것**인 반면, 작업 기억 공간의 역할은 **정보를 처리하는 것**이다
- 작업 기억 공간도 **특정한 문제에 적용된 STM** 이기 때문에 STM 과 같은 제한이 있다
  - 2~6개로 작업 기억 공간의 맥락에서 이 용량을 `인지 부하` 라고 부른다.

### 4.1.2. 프로그래밍과 관련한 인지 부하의 종류
- 내재적 부하 : **문제 자체**가 얼마나 복잡한지
- 외재적 부하 : **외부적 요인**에 의해 문제에 추가된 것
- 본유적 부하 : 생각을 **LTM에 저장하는 과정에서** 일어나는 인지 부하

#### 코드를 읽을 때 내재적 인지 부하
- 내재적 인지 부하는 **문제 그 자체가 갖는 특성** 때문에 발생하는 인지 부하다

#### 코드를 읽을 때 외재적 인지 부하
- 외재적 인지 부하는 어떤 문제가 두뇌에 일으키는 **자연적이고 내재적인 부하에 '더해서' 문제에 추가**되는 인지부하다
- 외재적 부하는 프로그래밍의 우발적 복합성과 유사하다
  - 우발적 복합성 <-> 본질적 복합성 (문제 자체의 복합성)
  - 우발적 복합성 : 문제 그 자체보다 문제를 풀려는 과정이 과도하게 복잡해진 것
- **외재적 인지 부하가 동일한지 여부는 이미 갖고 있는 지식에 달려 있다**

## 4.2. 인지 부하를 줄이기 위한 기법
### 4.2.1. 리팩터링
- 대개 리팩터링은 코드의 유지보수를 쉽게 하기 위한 목적으로 이루어진다 
- 하지만 코드가 전체적으로 유지보수하기 좋게 수정되었다고 해서 가독성까지 반드시 좋아지는 것은 아니다
  - **탈국지화된 코드는 여러 군데서 메서드 내부 구현을 찾아봐야 해서 작업 기억 공간에는 어려움을 줄 수 있다**
- `인지적 리팩터링` : 유지보수하기 좋은 코드를 작성하기보다, 장기적으로 가독성이 높은 코드를 작성하는 것
  - 리팩토링과 마찬가지로 코드가 외부로 제공하는 기능을 변경하지는 않는다
  - 다만 목표가 코드를 유지보수하기 좋게 만드는 게 아니라 **현 시점에서 개발자가 읽기 쉬운 코드로 변경하는 것**
  - 때로는 역 리팩토링을 수반할 수도 있다. 즉, 오히려 코드의 유지보수성을 낮추는 결과를 가져올 수도 있다
    - ex) 인라인 메소드 구현 : 외재적 인지 부하를 낮추고 코드를 이해하는 데 도움이 된다
    - ex) 코드 내 메소드 순서 변경 : 어떤 메소드가 최초로 호출되는 위치로부터 가까이 정의되어 있다면 코드의 가독성이 좋아진다
- 사람마다 지식에 따라 코드 이해도와 리팩토링 하는 내용도 다르므로 인지적 리팩토링은 개발자 자신만을 위한 리팩토링이다

### 4.2.2. 생소한 언어 구성 요소를 다른 것으로 대치하기
- 익숙하지 않은 언어 구성 요소는 작업 기억 공간에 외재적 인지 부하를 늘리므로, 복잡한 코드를 읽을 때 이들로 인한 부하가 늘어나지 않도록 하는 게 좋다
  - ex) 람다, 3항 연산자

### 4.2.3. 플래시카드에 코드 동의어 추가
- 프로그래밍 언어의 고급 개념에 대해서는, 프롬프트 대신 플래시카드 앞면까지 양면에 모두 코드를 적으면 더 나은 효과를 얻을 수 있다
- 앞면 : 삼항 연산자, 람다 같은 고급 개념 사용한 코드 / 뒷면 : 그에 해당하는 전통적인 방식의 코드

## 4.3. 작업 기억 공간에 부하가 오면 사용할 수 있는 기억 보조 수단
- 복잡한 구조의 코드는 2가지 방식으로 작업 기억 공간에 과부하를 유발한다
  1. 정확히 코드의 어디를 파악해야 하는지 모를 때
       - 필요 이상으로 많은 코드를 읽게 됨
  2. 코드가 서로 밀접하게 연결되어 있는 경우 두뇌는 2가지 작업을 동시에 수행한다
       - 코드의 개별 라인을 이해하면서, 어느 부분을 계속 읽어야 하는지 판단하기 위해 코드 구조를 이해해야 한다

### 4.3.1. 의존 그래프 생성
- 의존그래프를 만들면, 흐름을 이해하고 논리적 흐름에 따라 코드를 읽는 데 도움이 된다.
  1. 모든 변수를 원으로 표시한다
  2. 비슷한 변수를 연결한다
       - 프로그램에서 데이터가 사용된 위치를 이해하는 데 도움이 된다
       - 인지 부하가 줄고, 작업 기억 공간은 코드 기능에 좀 더 집중할 수 있다
  3. 모든 메서드나 함수 호출을 원으로 표시한다
  4. 메서드나 함수 호출을 정의와 연결한다
  5. 클래스의 모든 인스턴스를 원으로 표시한다
  6. 클래스와 그 클래스 인스턴스를 연결한다
- 코드를 찾기 위해 낭비하는 시간을 줄이고 필요한 코드만 읽을 수 있다

### 4.3.2. 상태표 사용
- 계산이 많은 코드를 파악할 때 도움이 되는 보조 수단으로는 `상태표` 가 있다
- 상태표는 코드의 구조보다는 **변수의 값**에 중점을 둔다
  - 열 : 변수 / 행 : 해당 변수가 각 단계에서 갖는 값
1. 모든 변수를 나열한다
2. 테이블을 만들고 각 열에 하나의 변수를 기입한다
3. 코드 실행단계마다 행을 만든다
4. 코드를 각 단계별로 실행하고, 그 단계에서 변수들의 값을 해당하는 열과 행에 적는다

### 4.3.3. 의존 그래프와 상태표의 혼용
- 의존그래프는 **코드의 구조**를 보여주고, 상태표는 **코드에서 이루어지는 계산 결과**를 보여준다

## 요약
- 내재적 인지 부하 : 코드에 존재하는 복잡성에 기인
- 외재적 인지 부하 : 우발적으로 (코드가 표현되는 방식에 의해) 혹은 코드를 읽는 개발자의 지식의 부족에 기인
- 리팩토링은 코드를 읽는 사람이 **이미 가진 지식에 맞춰** 코드를 변경함으로써, 외재적 인지 부하를 줄이는 방법이다
- 의존 그래프는 **복잡하고 서로 밀접하게 연결된 코드를 이해**하는 데 도움이 된다
- 상태표는 **계산이 많이 수행되는 코드를 파악**하는데 유용하다


> 1. 인지 부하를 줄이기 위해 리팩토링 시 인라인 메소드 구현으로 대체하는 것도 고려해보자
> 2. 복잡한 계산이 수행되는 경우 상태표를 고려하자
> 3. 개발자가 읽기 쉬운 코드를 짜자 (유지보수하기 좋은 코드도 물론 좋지만... 코드는 반드시 읽기 쉬워야 한다고 요즘 느낀다)