# Chapter 10. 복잡한 문제 해결을 더 잘하려면

- 이 장에서는 문제 해결에 도움이 되는 기술에 대해 살펴볼텐데, LTM을 강화하는 데 중점을 둔다.
- 이 장을 마치게 되면 프로그래밍과 문제 해결 능력을 향상하기 위한 두 가지 기술을 알게 될 것이다.

> [!IMPORTANT]
> 1. 자동화
> 2. 다른 사람이 작성한 코드를 활용해 문제를 해결하는 방법
  

렛츠고
## 10.1 문제 해결이란 무엇인가?
문제 해결을 잘할 방법을 배우기 전에 먼저, 문제 해결을 한다는 것이 무엇인지 알아보자.

### 문제 해결 요소
- 문제 해결에는 세 가지 중요한 요소가 있다.
  - 목표 상태, 즉 우리가 달성하고자 하는 것. 목표 상태에 도달하면 문제가 해결된 것으로 간주한다.
  - 문제를 해결해야 하는 시작 상태
  - 시작 상태에서 목표 상태에 도달하는 방법을 규정하는 규칙
> [!NOTE]
> 예시 : 기존 웹 사이트에 검색 상자를 추가하는 문제
 > - 시작 상태 : 기존 코드 베이스
 > - 원하는 상태 : 단위 테스트 통과 또는 사용자 만족
 > - 규칙 : 자바스크립트로 구현한다, 구현 후 기능 테스트에서 통과해야 한다 등

### 상태 공간
- 상태 공간<sub>state space</sub> : 프로그램을 해결할 때 고려할 수 있는 모든 단계
> [!NOTE]
> 예시 : 웹 사이트에 버튼을 추가하는 문제
  > - 상태공간은 모든 자바스크립트 프로그램
  > - 출발 목표에 도달하기 위해 코드 줄을 추가하는 것은 문제 해결자의 몫
- 즉, 문제 해결은 **가능한 한 `적은` 단계로 `목표 상태`에 도달하기 위해 `상태 공간`을 `최적화` 방식으로 탐색해 나가는 것을 의미**

## 10.2 프로그래밍 문제를 해결할 때 LTM의 역할은 무엇인가?
- 이제 문제를 해결할 때 두뇌에서 어떤 일이 일어나는지 살펴보자. 🧠
### 문제 해결은 그 자체로 인지 과정인가?
- 어떤 사람들은 문제해결이 일반적인 기술이며, 따라서 두뇌 속의 특정한 과정이라 생각
- 문제 해결 분야에서 유명한 사상가인 수학자 포여 죄르지는 문제를 해결하기 위해 세 가지 단계를 수반하는 '사고 체계'를 제안
  ```
  1. 문제 이해
  2. 계획 수립
  3. 계획 실행
  ```

- 그러나 일반적인 접근법의 인기에도 불구하고, 문제 해결은 일반적 기술도, 인지 과정도 아니라는 것이 지금까지의 연구 결과가 일관되게 보여주는 사실
> [!IMPORTANT]
> 일반적인 문제 해결 방법이 효과적이지 않고 LTM의 작업과 관련이 있는 이유 두 가지
> 1. 문제 해결 시 LTM 사용
> 2. 두뇌는 익숙한 문제를 해결하는 것이 더 쉽다

#### 문제 해결 시 LTM 사용
- 우리는 어떤 문제를 풀 때 원하는 목표 상태와 적용해야 할 규칙에 대한 지식을 염두에 두어야 함.
- 우리가 설계할 수 있는 해결책은 문제 자체에 영향을 받음.

> [!NOTE]
> 예시 : 회문<sub>palindrome</sub>인지 여부를 확인하는 코드 구현
  > - 문제를 이해한다.
  > - 계획을 세운다(해석)
  >   - 수립하려는 계획은 해결책을 구현할 **프로그래밍 언어의 역량에 크게 좌우된다.. 예를 들어 사용하는 프로그래밍 언어가 문자열의 순서를 뒤바꾸는 메서드나 함수를 가지고 있느냐 갖고 있지 않느냐에 따라 계획 수립 난이도가 달라진다.
  > - 계획을 실행한다(해결)
  >   - 이 단계 역시 프로그래밍 언어의 이해도에 영향을 받는다.

#### 두뇌는 익숙한 문제를 해결하는 것이 더 쉽다
- LTM에 있는 기억은 서로에 대한 네트워크로 저장된다. 또한 어떤 문제에 대해 생각하는 동안 뇌가 LTM으로부터 정보를 인출한다.
- 포여의 '계획 수립'과 같은 일반적인 문제 해결 기술을 사용하면 인지 문제가 발생한다.
- LTM에는 유용한 전략이 많이 저장되어 있을 수 있으며, 두뇌가 문제를 해결할 때 이 전략을 인출하려고 한다.
- 그러나 일반적인 방법으로 문제를 해결하려고 하면, 관련 전략이 **발견되지 않을 수 있다.**
> [!NOTE]
> - LTM은 올바른 기억을 인출하기 위한 단서가 필요하다.
> - 단서가 구체적일수록, 올바른 기억을 찾을 가능성이 높다.
- 7장에서 다룬 것처럼, 한 영역에서 다른 영역으로 지식이 전이되는 일은 가능성이 낮다.
- 마찬가지로, 매우 일반적인 **문제 해결 영역의 지식이 다른 영역으로 전이될 가능성은 매우 낮다.**

### 문제 해결을 위한 LTM 교육 방법
- 문제 해결을 위해 어떻게 훈련해야 할까? 그것을 더 깊이 탐구하기 위해서 뇌가 어떻게 생각하는지 자세히 살펴볼 필요가 있다.
- 생각은 작업 기억 공간에 형성되고, LTM 및 STM과 강력한 협업을 통해 작동한다는 것을 앞에서 살펴보았다.
- 특정 문제에 대해 생각할 때, 예를 들어 웹 앱에 정렬 버튼을 구현하려고 하면, 작업 기억 공간이 무엇을 구현할지 결정한다.
- 그러나 작업 기억 공간이 결정을 내리기에 앞서 두 가지를 먼저 해야 한다.
  1. STM으로부터 문제 상황에 대한 정보 (예 : 버튼에 대한 요구사항 또는 방금 읽은 기존 코드)를 가져온다.
  2. 동시에 LTM은 관련 배경 지식을 검색한다. (코드 베이스에 대한 정렬 또는 정보 구현 방법에 대한 기억이 작업 기억 공간으로 전송됨)
> [!IMPORTANT]
> 문제 해결을 더 잘 이해하기 위해서는 LTM을 검색하는 두 번째 처리 과정을 탐구해야 한다.

### 문제 해결에 역할을 하는 두 가지 유형의 기억
<img src="https://github.com/user-attachments/assets/1e0f6849-b0c4-4cb0-a09c-98e65db554d8" width=400 />

> [!IMPORTANT]
> LTM은 다양한 유형의 기억을 저장할 수 있다.
> 1. 절차적<sub>procedural</sub>(암시적) 기억 : 운동 능력이나 의식하지 않고 발휘하는 기술에 대한 기억 (신발끈 묶기, 자전거 타는 법 등)
> 2. 선언적<sub>declaritive</sub>(명시적) 기억 : 우리가 명확하게 알고 있는 기억으로 구성 (버락 오바마가 미국의 44대 대통령이었다는 사실, 자바로 for 루프 쓰는 법 등)
  >  - 일화적<sub>episodic</sub> 기억 : 일상생활 가운데 경험한 것에 대한 기억. 우리가 일상적으로 기억<sub>memory</sub>이라는 단어를 사용할 때 의미하는 그 기억
  >  - 의미적<sub>semantic</sub> 기억 : 의미, 개념 또는 사실에 대한 기억 (프랑스어로 개구리가 grenouille이라는 사실, 5 곱하기 7은 35 등)

> [!NOTE]
> 3장에서 플래시 카드로 연습해서 기억한 것이 바로 의미적 기억
- 일회적 기억은 추가적인 노력을 하지 않아도 생성되지만, 의미적 기억과 마찬가지로 많이 생각해야만 인출 강도가 높아진다.


#### 문제를 해결할 때 어떤 유형의 기억이 역할을 수행하는가?
- 모든 형태의 기억은 프로그래밍할 때 수행하는 역할이 있다.
- 명시적 기억 : 자바에서 루프를 구성하는 방법을 기억
- 일화적 기억 : 과거에 문제를 어떻게 해결했는지 기억
  - 전문가들은 문제를 해결할 때 특히 순간적인 기억력에 크게 의존
  - 새로운 해결책을 찾는 대신 이전에 유사한 문제에 효과가 있었던 해결책에 의존
- 암시적 기억 : 데이터 타입 기억, 뒤로가기 단축키 Ctrl + Z 곧바로 사용, 버그가 있을 것으로 의심되는 줄에 자동으로 중단점 배치
  - 직감이라는 것ㅇ,ㄴ 사실 이전에 풀었던 것과 비슷한 문제를 풀 때 발휘된다.
  - 어떻게 해야하는지 아는 것이 아니라 무엇을 해야 하는지 알고 있을 뿐이다.
 

#### 탈학습
- 암시적 기억은 알려진 작업을 신속하게 처리하는 데 도움이 되지만, 이 유형의 기억을 갖는 것이 해로울 수도 있다.
- 무언가를 아는 것이 다른 것을 배우는 데 도움이 되는 것이 아니라 오히려 방해가 되는 것
- 암시적 기억이 많으면 유연성이 저해될 수도 있다.

> [!NOTE]
> 처음에 한 프로그래밍 언어를 배우고 나서 두 번째 언어를 배울 때 차이가 많이 난다면 암시적으로 기억된 학습 내용을 취소하는 데 어려움을 겪었을 것이다.

## 10.3 자동화 : 암시적 기억 생성
- 기술을 자동화하는 방법을 알려면 먼저 암시적 프로그래밍 기억을 강화하는 방법을 살펴봐야 한다.
- 인지 부하를 너무 많이 경험하게 되면, 생각하는 일이 매우 어려워질 수 있다.
- 암시적 기억을 충분히 훈련하면, 그것을 사용하는 데 뇌가 거의 에너지를 소모하지 않는다.

### 시간의 경과에 따른 암시적 기억
- 프로그래밍에 대한 암시적 기억이 많을수록 인지 부하를 더 많이 절약할 수 있기 때문에 더 큰 문제를 해결하기가 쉽다.
- 어떤 사실을 명시적 기억을 저장하려면 명시적 주의가 필요하다.
- 반면 암시적 기억은 다른 방식, 즉 반복에 의해 생성된다. 생각을 해서 얻어지는 것이 아니라 연습을 통해 만들어진다.
> [!IMPORTANT]
> 암시적 기억은 세 가지 단게로 형성된다.
> 1. 인지 단계 : 무언가 새로운 것을 배우는 때. 새로운 정보를 더 작은 부분으로 나누고 당면한 작업에 대해 명시적으로 생각한다.
>    - ex. 0에서 시작하면 인덱스가 3인 원소는 4번째 원소구나
> 2. 연상 단계 : 응답 패턴이 나타날 때까지 새 정보를 적극적으로 반복해야 한다.
>    - ex. 인덱스를 계산할 때는 항상 1을 빼면 되네.
> 3. 자율 단계 : 기술이 완벽한 자율 단계(절차 단게)에 도달한다. 기술을 자동화했다고 볼 수 있다. 아무런 노력 없이 그 일을 수행할 수 있고, 그 기술을 쓴다고 해서  인지 부하가 증가하지 않는다.
>    - ex. `[7, 4, 2, 1, 5]` 리스트에서 `list[4]`는 5네!

### 자동화를 통해 보다 신속하게 프로그램을 실행할 수 있는 이유
- 기술에 대한 대규모 저장소를 만들면 새로운 기술을 습득해나갈 수 있는 일종의 툴박스를 만들 수 있다.
- 인스턴스 이론
  
  - 미국의 심리학자 고든 로건은 자동화는 LTM의 일화적 기억이 저장된 부분으로부터 기억을 인출함으로써 이루어진다고 주장한다.
  - LTM은 일상생활의 규칙적인 기억도 저장한다.
  - 방정식을 소인수분해하거나 문자를 읽는 것과 같은 작업을 수행하면 그런 구체적 작업에 해당하는 새로운 기억이 생성된다.
  - 각각의 기억은 예를 들어 '인수분해에 대한 기억'이라는 클래스의 한 인스턴스로 간주되기 때문에, 이 이론을 인스턴스 이론이라고 부른다.
- 인스턴스 기억을 많이 가지고 있다면 이전에 수행했던 방법을 기억하고 동일한 방법 적용 가능
- 추론을 전혀 사용하지 않고 순간적인 기억에 전적으로 의존할 때 자동화는 완전해진다.

### 암시적 기억 개선
- 자율 단계에 도달하지 않은 기술을 의도적으로 연습해 개선할 방안을 살펴보자.
- 프로그래밍에서는 의도적 연습을 보통 하지 않는다.
- 하지만 다른 방법으로 의도적 연습을 할 수 있다.
> [!IMPORTANT]
> - 연습하고자 하는 기술이 필요한, 유사하지만 다른 프로그램을 많이 작성해봐라.
> - 보다 복잡한 프로그래밍 개념을 이해하는 데 어려움을 겪고 있다면 프로그램을 처음부터 작성하는 것보다 이미 작성된 프로그램을 수정하는 것도 고려해봐라.
>   - 새로운 개념들이 이미 알고 있는 개념들과 어떻게 다른지 그 차이점에 집중해서 살펴보는 데 도움이 된다.
- 간격을 둔 반복은 학습의 핵심이다.
- 아무런 노력 없이도 작업을 일관되게 할 수 있을 때까지 매일 연습을 계속해보라.
- 프로그래밍 영역에서 드문 일이기에 이런 연습이 이상하게 생각될 수도 있지만 계속 시도해보기 바란다. 반복할 때마다 조금씩 더 강해진다.


## 10.4 코드와 해설에서 배우기
- 문제 해결 능력을 향상하기 위해 사용할 수 있는 두 번째 방법은 다른 사람들이 문제를 어떻게 해결했는지 의도적으로 연구하는 것이다.
- 다른 사람이 문제를 어떻게 해결했는지 연구함으로써 얻는 해결책을 종종 **풀이된 예제**라고 부른다.
- 풀이된 예제는 수학, 음악, 체스, 스포츠, 프로그래밍을 포함한 다양한 연령 그룹과 주제에 대한 연구 결과에서 그 효과가 입증되었다.

### 새로운 유형의 인지 부하 : 본유적 부하
- 종종 우리는 아이들이 문제 해결을 잘 할 수 있기를 바란다면 스스로 문제를 해결하도록 내버려두어야 한다고 생각한다.
- 마찬가지로 좋은 프로그래머가 되고 싶다면, 많은 프로그램을 작성해봐야 한다고 생각한다.
- 그러나 결과는 반드시 그렇지만은 않다.
- 이는 작업 기억 공간의 인지 부하와 관련이 있다.

<img width="839" alt="image" src="https://github.com/user-attachments/assets/8eb34b2d-d6cf-47d0-b4c2-de17ff5bad1b" />

- 빨간색 표시된 화살표 부분이 활성화되고 작업 기억 공간의 내용이 LTM에 저장되려면, 본유적 부하가 뒤따른다.
- 작업 기억 공간의 부하가 너무 크면 이것이 어려워진다.
- 본유적 부하 : 두뇌가 정보를 LTM에 다시 저장하기 위해 수행하는 노력
- 인지 부하가 내재적 부하와 외재적 부하로 가득 차면, 본유적 부하를 위한 여지는 남아 있지 않게 된다. 그래서 기억을 못하는 것임.
- 따라서 레시피(풀이된 예제)가 있는 경우 인지 부하가 높지 않기 떄문에 레시피를 자세히 검토하고 이후에 기억할 수 있다.
- 더 나은 프로그래머가 되고 싶다면, 프로그램을 많이 작성하라!는 이 연구를 보면 사실이 아닌 것으로 보인다.
- 아이들은 프로그램을 읽고 이에 대한 설명을 통해 배우는 것이 프로그램을 작성하며 배울 때보다 배우는 것이 더 많다.


### 개발 작업 시 풀이된 예제 활용하기
> [!IMPORTANT]
> - **동료와 협업하기**
  > - 코드를 혼자 공부할 필요는 없다. 누군가와 함께하는 것이 더 유용하다.
  > - 자신만의 코드와 요약을 혼자 공부할 수도 있지만, 자신이 작성한 코드에 대해 먼저 요약한 후 다른 동료와 공유하고, 동료의 코드로부터 배우는 2단계 프로세스를 사용하면 더욱 강력해진다.
> - **깃허브 탐구**
>   - 깃허브는 코드를 읽기 위한 훌륭한 사이트
>   - 어느 정도 알고 있는 저장소의 코드, 예를 들면 자신이 현재 사용하는 라이브러리의 코드를 읽으면 된다.
>   - 도메인이 조금이라도 익숙한 저장소를 선핵하는 것이 가장 권장할 만함 (낯선 단어와 개념으로 인한 외재적 부하 없이 프로그래밍 자체에 집중할 수 있기 때문)
> - **소스 코드에 대한 책 또는 블로그 게시물 읽기**
